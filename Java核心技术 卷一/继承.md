#### 继承

关键字：extents

Java 不支持多继承。

##### 覆盖方法

子类方法不能直接访问父类的私有域，虽然**子类对象**拥有父类所有的域与方法。

子类方法必须借助公有的接口访问父类的私有域，通过super.方法()

子类中可以添加域、添加方法或覆盖父类的方法，但是不能删除继承的任何域和方法。

**重写规则**

- 参数列表必须相同
- 子类重写方法的返回类型必须是父类方法返回类型的派生类，或相同
- 访问权限不能比父类被重写的方法的访问权限低
- final修饰的方法不可以重写
- static修饰方法不可以重写，但是可以重载
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写
- 如果不能继承一个类，则不能重写该类的方法。final修饰的类就不能被继承

##### 子类构造器

```java
public Manager(String name,double salary,int year,int month,int day){
    super(name,salary,year,month,day); //super调用父类构造器必须在子类构造器第一行
    //如果没有显式调用父类构造器，则自动调用父类默认构造器
    bonus=0;
}
```

##### 多态

一个对象变量可以指示多种实际类型的现象，比如父类对象变量指向子类对象

**存在的三个必要条件**：

- 继承
- 重写
- 父类引用指向子类对象

```java
//Child派生于Parent，Child重写了Parent的show()方法
Parent p1 = new Parent();
Parent p2 = new Child(); //向上转型，多态
Child c1 = (Child) p2; //向下转型，因为经过了一次向上转型，所以向下转型没有问题
Child c2 = new Parnet(); //不合法，不能直接向下转型，将子类引用指向父类对象

//在进行类型转换之前， 先查看一下是否能够成功地转换。使用instanceof 操作符就可以实现。
if (Parnet instanceof Child)
{
	Child c2 = (Manager) new Parnet();
}

//动态绑定
p1.show(); //执行的Parent的show()方法
p2.show(); //执行的Child的show()方法

//p2不能调用子类独有的方法，只能调用父类已有的方法或者被覆盖的方法
```

##### 抽象类

关键字：abstract

抽象类不能被实例化

抽象类可以引用非抽象子类的实例

抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

```java
//除了抽象方法之外， 抽象类还可以包含具体数据和具体方法。 
public abstract class Person
{
	private String name;
	public Person(String name){
		this.name = name;
	}
    //子类必须重写getDescription()方法，或者声明自身为抽象类
	public abstract String getDescription();
	public String getName0{
        return name;
	}
}

public class Student extends Person
{
    private String major;
    public Student(String name, String major){
        super(name);
        this.major = major;
    }
    //实现抽象父类的抽象方法
    public String getDescription(){
    	return "a student majoring in " + major;
    }
}

//抽象类不能被实例化
Person p = new Person(); //错误的

//抽象类引用非抽象子类的实例
Person p = new Student();
```

##### Object

所有类的父类

如果类没有指明父类，Object默认为该类的父类

- equals()

  检测两个对象是否具有相同的引用

- hashCode()

  散列码，默认返回对象的存储地址。

- toString()

  返回表示对象值的字符串，默认返回对象所属的类名和散列码



